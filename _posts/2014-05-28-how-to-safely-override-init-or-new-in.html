---
layout: post
title: How to safely override __init__ or __new__ in Python 2.6 and later
date: '2014-05-28T14:45:00.000-07:00'
author: Jason R. Coombs
tags: 
modified_time: '2014-05-28T14:45:00.647-07:00'
blogger_id: tag:blogger.com,1999:blog-3597351713969111277.post-7342553203692710513
blogger_orig_url: http://blog.jaraco.com/2014/05/how-to-safely-override-init-or-new-in.html
---

Beginning with Python 2.6, following from <a href="http://bugs.python.org/issue1683368">bug 1683368</a>, object.__init__ and object.__new__ deprecate the support for arbitrary arguments. The old behavior was deprecated in Python 2.6 and removed in Python 3.3. As a result, any subclass that overrides either of these methods must be aware of the presence or absence of the overridden method in the MRO up to but not including 'object'. I articulated this unexpected behavior in <a href="http://bugs.python.org/issue1683368#msg219300">this post</a>, giving a simple trivial example.<br /><br />If that's confusing, don't fret. The details aren't important, because what I'm presenting here is a technique that's engineered to be safe in all cases without baking in the details of the parent class.<br /><br /><pre><span class="k">class</span> <span class="nc">SomeClass</span><span class="p">(</span><span class="n">SomeParentClass</span><span class="p">):</span><br />    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span><br />        <span class="n">super_new</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><br />        <span class="k">if</span> <span class="n">super_new</span> <span class="ow">is</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">:</span><br />            <span class="k">return</span> <span class="n">super_new</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span><br />        <span class="k">return</span> <span class="n">super_new</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><br /><br />    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span><br />        <span class="n">super_init</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><br />        <span class="k">if</span> <span class="n">super_init</span><span class="o">.</span><span class="n">__objclass__</span> <span class="ow">is</span> <span class="nb">object</span><span class="p">:</span><br />            <span class="k">return</span><br />        <span class="n">super_init</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></pre><pre><span class="p">&nbsp;</span></pre><span class="p">The above example presents a generic, trivial implementation of a subclass of SomeParentClass that overrides both __init__ and __new__. It does not add any custom behavior (as a typical override would), but instead focuses on the technique on passing through the calls of __init__ and __new__ to the parent class in a safe way.</span><br /><br /><span class="p">If you're overriding __new__ or __init__, especially in a subclass of a class over which you do not have control over the implementation, it is important that you check that the parent call will not invoke __new__ or __init__ with parameters. Otherwise, you may run into one of the following errors when constructing your subclass:</span><br /><span class="p"><br /></span><span class="p">TypeError: object.__init__ takes no parameters.</span><br /><span class="p">TypeError: object.__new__ takes no parameters.</span><br /><br /><br />